{"version":3,"file":"hammer.min.js","sources":["../src/utils/assign.js","../src/browser.js","../src/utils/utils-consts.js","../src/utils/prefixed.js","../src/touchactionjs/get-touchaction-props.js","../src/touchactionjs/touchaction-Consts.js","../src/inputjs/input-consts.js","../src/utils/each.js","../src/utils/bool-or-fn.js","../src/utils/in-str.js","../src/touchactionjs/touchaction-constructor.js","../src/touchactionjs/clean-touch-actions.js","../src/utils/has-parent.js","../src/inputjs/get-center.js","../src/inputjs/simple-clone-input-data.js","../src/inputjs/get-distance.js","../src/inputjs/get-angle.js","../src/inputjs/get-direction.js","../src/inputjs/get-velocity.js","../src/inputjs/compute-input-data.js","../src/inputjs/compute-delta-xy.js","../src/inputjs/get-scale.js","../src/inputjs/get-rotation.js","../src/inputjs/compute-interval-input-data.js","../src/inputjs/input-handler.js","../src/utils/split-str.js","../src/utils/add-event-listeners.js","../src/utils/remove-event-listeners.js","../src/utils/get-window-for-element.js","../src/inputjs/input-constructor.js","../src/utils/in-array.js","../src/input/pointerevent.js","../src/utils/to-array.js","../src/utils/unique-array.js","../src/input/touch.js","../src/input/mouse.js","../src/input/touchmouse.js","../src/utils/invoke-array-arg.js","../src/recognizerjs/recognizer-consts.js","../src/utils/unique-id.js","../src/recognizerjs/get-recognizer-by-name-if-manager.js","../src/recognizerjs/state-str.js","../src/recognizerjs/recognizer-constructor.js","../src/recognizers/tap.js","../src/recognizers/attribute.js","../src/recognizerjs/direction-str.js","../src/recognizers/pan.js","../src/recognizers/swipe.js","../src/recognizers/pinch.js","../src/recognizers/rotate.js","../src/recognizers/press.js","../src/defaults.js","../src/manager.js","../src/inputjs/create-input-instance.js","../src/input/singletouch.js","../src/utils/deprecate.js","../src/utils/extend.js","../src/utils/merge.js","../src/utils/inherit.js","../src/utils/bind-fn.js","../src/hammer.js"],"sourcesContent":["/**\r\n * @private\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} target\r\n * @param {...Object} objects_to_assign\r\n * @returns {Object} target\r\n */\r\nlet assign;\r\nif (typeof Object.assign !== 'function') {\r\n  assign = function assign(target) {\r\n    if (target === undefined || target === null) {\r\n      throw new TypeError('Cannot convert undefined or null to object');\r\n    }\r\n\r\n    let output = Object(target);\r\n    for (let index = 1; index < arguments.length; index++) {\r\n      const source = arguments[index];\r\n      if (source !== undefined && source !== null) {\r\n        for (const nextKey in source) {\r\n          if (source.hasOwnProperty(nextKey)) {\r\n            output[nextKey] = source[nextKey];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n} else {\r\n  assign = Object.assign;\r\n}\r\n\r\nexport default assign;","/* eslint-disable no-new-func, no-nested-ternary */\r\n\r\nlet win;\r\n\r\nif (typeof window === \"undefined\") {\r\n\t// window is undefined in node.js\r\n\twin = {};\r\n} else {\r\n\twin = window;\r\n}\r\n/* eslint-enable no-new-func, no-nested-ternary */\r\n\r\nexport {win as window};\r\n","\r\nconst VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\r\nconst TEST_ELEMENT = typeof document === \"undefined\" ? {style: {}} : document.createElement('div');\r\n\r\nconst TYPE_FUNCTION = 'function';\r\n\r\nconst { round, abs } = Math;\r\nconst { now } = Date;\r\n\r\nexport {\r\n    VENDOR_PREFIXES,\r\n    TEST_ELEMENT,\r\n    TYPE_FUNCTION,\r\n    round,\r\n    abs,\r\n    now\r\n};\r\n","import { VENDOR_PREFIXES } from './utils-consts';\r\n/**\r\n * @private\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nexport default function prefixed(obj, property) {\r\n  let prefix;\r\n  let prop;\r\n  let camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n  let i = 0;\r\n  while (i < VENDOR_PREFIXES.length) {\r\n    prefix = VENDOR_PREFIXES[i];\r\n    prop = (prefix) ? prefix + camelProp : property;\r\n\r\n    if (prop in obj) {\r\n      return prop;\r\n    }\r\n    i++;\r\n  }\r\n  return undefined;\r\n}\r\n","import prefixed from '../utils/prefixed';\r\nimport { TEST_ELEMENT } from '../utils/utils-consts';\r\nimport {window} from '../browser';\r\n\r\nexport const PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\r\nexport const NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\nexport default function getTouchActionProps() {\r\n  if (!NATIVE_TOUCH_ACTION) {\r\n    return false;\r\n  }\r\n  let touchMap = {};\r\n  let cssSupports = window.CSS && window.CSS.supports;\r\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((val) => {\r\n\r\n    // If css.supports is not supported but there is native touch-action assume it supports\r\n    // all values. This is the case for IE 10 and 11.\r\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\r\n  });\r\n  return touchMap;\r\n}\r\n","import getTouchActionProps from './get-touchaction-props';\r\n\r\n\r\n\r\n// magical touchAction value\r\nconst TOUCH_ACTION_COMPUTE = 'compute';\r\nconst TOUCH_ACTION_AUTO = 'auto';\r\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\nconst TOUCH_ACTION_NONE = 'none';\r\nconst TOUCH_ACTION_PAN_X = 'pan-x';\r\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\r\nconst TOUCH_ACTION_MAP = getTouchActionProps();\r\n\r\nexport {\r\n  TOUCH_ACTION_AUTO,\r\n  TOUCH_ACTION_COMPUTE,\r\n  TOUCH_ACTION_MANIPULATION,\r\n  TOUCH_ACTION_NONE,\r\n  TOUCH_ACTION_PAN_X,\r\n  TOUCH_ACTION_PAN_Y,\r\n  TOUCH_ACTION_MAP\r\n};\r\n","import prefixed from '../utils/prefixed';\r\nimport {window} from \"../browser\";\r\n\r\nconst MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nconst SUPPORT_TOUCH = ('ontouchstart' in window);\r\nconst SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nconst SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nconst INPUT_TYPE_TOUCH = 'touch';\r\nconst INPUT_TYPE_PEN = 'pen';\r\nconst INPUT_TYPE_MOUSE = 'mouse';\r\nconst INPUT_TYPE_KINECT = 'kinect';\r\n\r\nconst COMPUTE_INTERVAL = 25;\r\n\r\nconst INPUT_START = 1;\r\nconst INPUT_MOVE = 2;\r\nconst INPUT_END = 4;\r\nconst INPUT_CANCEL = 8;\r\n\r\nconst DIRECTION_NONE = 1;\r\nconst DIRECTION_LEFT = 2;\r\nconst DIRECTION_RIGHT = 4;\r\nconst DIRECTION_UP = 8;\r\nconst DIRECTION_DOWN = 16;\r\n\r\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nconst PROPS_XY = ['x', 'y'];\r\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\nexport {\r\n    MOBILE_REGEX,\r\n    SUPPORT_ONLY_TOUCH,\r\n    SUPPORT_POINTER_EVENTS,\r\n    SUPPORT_TOUCH,\r\n    INPUT_TYPE_KINECT,\r\n    INPUT_TYPE_MOUSE,\r\n    INPUT_TYPE_PEN,\r\n    INPUT_TYPE_TOUCH,\r\n    COMPUTE_INTERVAL,\r\n    INPUT_START,\r\n    INPUT_MOVE,\r\n    INPUT_END,\r\n    INPUT_CANCEL,\r\n    DIRECTION_NONE,\r\n    DIRECTION_LEFT,\r\n    DIRECTION_RIGHT,\r\n    DIRECTION_UP,\r\n    DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL,\r\n    DIRECTION_ALL,\r\n    PROPS_XY,\r\n    PROPS_CLIENT_XY\r\n};\r\n","/**\r\n * @private\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nexport default function each(obj, iterator, context) {\r\n  let i;\r\n\r\n  if (!obj) {\r\n    return;\r\n  }\r\n\r\n  if (obj.forEach) {\r\n    obj.forEach(iterator, context);\r\n  } else if (obj.length !== undefined) {\r\n    i = 0;\r\n    while (i < obj.length) {\r\n      iterator.call(context, obj[i], i, obj);\r\n      i++;\r\n    }\r\n  } else {\r\n    for (i in obj) {\r\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n    }\r\n  }\r\n}\r\n","import { TYPE_FUNCTION } from './utils-consts';\r\n/**\r\n * @private\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nexport default function boolOrFn(val, args) {\r\n  if (typeof val === TYPE_FUNCTION) {\r\n    return val.apply(args ? args[0] || undefined : undefined, args);\r\n  }\r\n  return val;\r\n}\r\n","/**\r\n * @private\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nexport default function inStr(str, find) {\r\n  return str.indexOf(find) > -1;\r\n}\r\n","import {\r\n    TOUCH_ACTION_COMPUTE,\r\n    TOUCH_ACTION_MAP,\r\n    TOUCH_ACTION_NONE,\r\n    TOUCH_ACTION_PAN_X,\r\n    TOUCH_ACTION_PAN_Y\r\n} from './touchaction-Consts';\r\nimport {\r\n  NATIVE_TOUCH_ACTION,\r\n  PREFIXED_TOUCH_ACTION,\r\n} from \"./get-touchaction-props\";\r\nimport {\r\n    DIRECTION_VERTICAL,\r\n    DIRECTION_HORIZONTAL\r\n} from '../inputjs/input-consts';\r\nimport each from '../utils/each';\r\nimport boolOrFn from '../utils/bool-or-fn';\r\nimport inStr from '../utils/in-str';\r\nimport cleanTouchActions from './clean-touch-actions';\r\n\r\n/**\r\n * @private\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nexport default class TouchAction {\r\n  constructor(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * set the touchAction value on the element or enable the polyfill\r\n   * @param {String} value\r\n   */\r\n  set(value) {\r\n    // find out the touch-action by the event handlers\r\n    if (value === TOUCH_ACTION_COMPUTE) {\r\n      value = this.compute();\r\n    }\r\n\r\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\r\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n    }\r\n    this.actions = value.toLowerCase().trim();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * just re-set the touchAction value\r\n   */\r\n  update() {\r\n    this.set(this.manager.options.touchAction);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * compute the value for the touchAction property based on the recognizer's settings\r\n   * @returns {String} value\r\n   */\r\n  compute() {\r\n    let actions = [];\r\n    each(this.manager.recognizers, (recognizer) => {\r\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\r\n        actions = actions.concat(recognizer.getTouchAction());\r\n      }\r\n    });\r\n    return cleanTouchActions(actions.join(' '));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * this method is called on each input cycle and provides the preventing of the browser behavior\r\n   * @param {Object} input\r\n   */\r\n  preventDefaults(input) {\r\n    let { srcEvent } = input;\r\n    let direction = input.offsetDirection;\r\n\r\n    // if the touch action did prevented once this session\r\n    if (this.manager.session.prevented) {\r\n      srcEvent.preventDefault();\r\n      return;\r\n    }\r\n\r\n    let { actions } = this;\r\n    let hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\r\n    let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\r\n    let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\r\n\r\n    if (hasNone) {\r\n      // do not prevent defaults if this is a tap gesture\r\n      let isTapPointer = input.pointers.length === 1;\r\n      let isTapMovement = input.distance < 2;\r\n      let isTapTouchTime = input.deltaTime < 250;\r\n\r\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (hasPanX && hasPanY) {\r\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\r\n      return;\r\n    }\r\n\r\n    if (hasNone ||\r\n        (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n        (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n      return this.preventSrc(srcEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n   * @param {Object} srcEvent\r\n   */\r\n  preventSrc(srcEvent) {\r\n    this.manager.session.prevented = true;\r\n    srcEvent.preventDefault();\r\n  }\r\n}\r\n","import inStr from '../utils/in-str';\r\nimport {\r\n    TOUCH_ACTION_NONE,\r\n    TOUCH_ACTION_PAN_X,\r\n    TOUCH_ACTION_PAN_Y,\r\n    TOUCH_ACTION_MANIPULATION,\r\n    TOUCH_ACTION_AUTO\r\n} from './touchaction-Consts';\r\n\r\n/**\r\n * @private\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nexport default function cleanTouchActions(actions) {\r\n  // none\r\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n    return TOUCH_ACTION_NONE;\r\n  }\r\n\r\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\r\n  // if both pan-x and pan-y are set (different recognizers\r\n  // for different directions, e.g. horizontal pan but vertical swipe?)\r\n  // we need none (as otherwise with pan-x pan-y combined none of these\r\n  // recognizers will work, since the browser would handle all panning\r\n  if (hasPanX && hasPanY) {\r\n    return TOUCH_ACTION_NONE;\r\n  }\r\n\r\n  // pan-x OR pan-y\r\n  if (hasPanX || hasPanY) {\r\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\r\n  }\r\n\r\n  // manipulation\r\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n    return TOUCH_ACTION_MANIPULATION;\r\n  }\r\n\r\n  return TOUCH_ACTION_AUTO;\r\n}\r\n","/**\r\n * @private\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nexport default function hasParent(node, parent) {\r\n  while (node) {\r\n    if (node === parent) {\r\n      return true;\r\n    }\r\n    node = node.parentNode;\r\n  }\r\n  return false;\r\n}\r\n","import { round } from '../utils/utils-consts';\r\n\r\n/**\r\n * @private\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nexport default function getCenter(pointers) {\r\n  let pointersLength = pointers.length;\r\n\r\n  // no need to loop when only one touch\r\n  if (pointersLength === 1) {\r\n    return {\r\n      x: round(pointers[0].clientX),\r\n      y: round(pointers[0].clientY)\r\n    };\r\n  }\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let i = 0;\r\n  while (i < pointersLength) {\r\n    x += pointers[i].clientX;\r\n    y += pointers[i].clientY;\r\n    i++;\r\n  }\r\n\r\n  return {\r\n    x: round(x / pointersLength),\r\n    y: round(y / pointersLength)\r\n  };\r\n}\r\n","import { now,round } from '../utils/utils-consts';\r\nimport getCenter from './get-center';\r\n\r\n/**\r\n * @private\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nexport default function simpleCloneInputData(input) {\r\n  // make a simple copy of the pointers because we will get a reference if we don't\r\n  // we only need clientXY for the calculations\r\n  let pointers = [];\r\n  let i = 0;\r\n  while (i < input.pointers.length) {\r\n    pointers[i] = {\r\n      clientX: round(input.pointers[i].clientX),\r\n      clientY: round(input.pointers[i].clientY)\r\n    };\r\n    i++;\r\n  }\r\n\r\n  return {\r\n    timeStamp: now(),\r\n    pointers,\r\n    center: getCenter(pointers),\r\n    deltaX: input.deltaX,\r\n    deltaY: input.deltaY\r\n  };\r\n}\r\n","import { PROPS_XY } from './input-consts';\r\n\r\n/**\r\n * @private\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nexport default function getDistance(p1, p2, props) {\r\n  if (!props) {\r\n    props = PROPS_XY;\r\n  }\r\n  let x = p2[props[0]] - p1[props[0]];\r\n  let y = p2[props[1]] - p1[props[1]];\r\n\r\n  return Math.sqrt((x * x) + (y * y));\r\n}\r\n","import { PROPS_XY } from './input-consts';\r\n\r\n/**\r\n * @private\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nexport default function getAngle(p1, p2, props) {\r\n  if (!props) {\r\n    props = PROPS_XY;\r\n  }\r\n  let x = p2[props[0]] - p1[props[0]];\r\n  let y = p2[props[1]] - p1[props[1]];\r\n  return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n","import { abs } from '../utils/utils-consts';\r\nimport { DIRECTION_NONE,DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN } from './input-consts';\r\n\r\n/**\r\n * @private\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nexport default function getDirection(x, y) {\r\n  if (x === y) {\r\n    return DIRECTION_NONE;\r\n  }\r\n\r\n  if (abs(x) >= abs(y)) {\r\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n  }\r\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n","/**\r\n * @private\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nexport default function getVelocity(deltaTime, x, y) {\r\n  return {\r\n    x: x / deltaTime || 0,\r\n    y: y / deltaTime || 0\r\n  };\r\n}\r\n","import { now } from '../utils/utils-consts';\r\nimport { abs } from '../utils/utils-consts';\r\nimport hasParent from '../utils/has-parent';\r\nimport simpleCloneInputData from './simple-clone-input-data';\r\nimport getCenter from './get-center';\r\nimport getDistance from './get-distance';\r\nimport getAngle from './get-angle';\r\nimport getDirection from './get-direction';\r\nimport computeDeltaXY from './compute-delta-xy';\r\nimport getVelocity from './get-velocity';\r\nimport getScale from './get-scale';\r\nimport getRotation from './get-rotation';\r\nimport computeIntervalInputData from './compute-interval-input-data';\r\n\r\n/**\r\n* @private\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nexport default function computeInputData(manager, input) {\r\n  let { session } = manager;\r\n  let { pointers } = input;\r\n  let { length:pointersLength } = pointers;\r\n\r\n  // store the first input to calculate the distance and direction\r\n  if (!session.firstInput) {\r\n    session.firstInput = simpleCloneInputData(input);\r\n  }\r\n\r\n  // to compute scale and rotation we need to store the multiple touches\r\n  if (pointersLength > 1 && !session.firstMultiple) {\r\n    session.firstMultiple = simpleCloneInputData(input);\r\n  } else if (pointersLength === 1) {\r\n    session.firstMultiple = false;\r\n  }\r\n\r\n  let { firstInput, firstMultiple } = session;\r\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\r\n  let center = input.center = getCenter(pointers);\r\n  input.timeStamp = now();\r\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\r\n  input.angle = getAngle(offsetCenter, center);\r\n  input.distance = getDistance(offsetCenter, center);\r\n\r\n  computeDeltaXY(session, input);\r\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\r\n  input.overallVelocityX = overallVelocity.x;\r\n  input.overallVelocityY = overallVelocity.y;\r\n  input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\r\n\r\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n  input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\r\n  session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\r\n\r\n  computeIntervalInputData(session, input);\r\n\r\n  // find the correct target\r\n  let target = manager.element;\r\n  const srcEvent = input.srcEvent;\r\n  let srcEventTarget;\r\n\r\n  if (srcEvent.composedPath) {\r\n    srcEventTarget = srcEvent.composedPath()[0];\r\n  } else if (srcEvent.path) {\r\n    srcEventTarget = srcEvent.path[0];\r\n  } else {\r\n    srcEventTarget = srcEvent.target;\r\n  }\r\n\r\n  if (hasParent(srcEventTarget, target)) {\r\n    target = srcEventTarget;\r\n  }\r\n  input.target = target;\r\n}\r\n","import { INPUT_START, INPUT_END } from './input-consts';\r\n\r\nexport default function computeDeltaXY(session, input) {\r\n  let { center } = input;\r\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\r\n  // jscs throwing error on defalut destructured values and without defaults tests fail\r\n  let offset = session.offsetDelta || {};\r\n  let prevDelta = session.prevDelta || {};\r\n  let prevInput = session.prevInput || {};\r\n\r\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\r\n    prevDelta = session.prevDelta = {\r\n      x: prevInput.deltaX || 0,\r\n      y: prevInput.deltaY || 0\r\n    };\r\n\r\n    offset = session.offsetDelta = {\r\n      x: center.x,\r\n      y: center.y\r\n    };\r\n  }\r\n\r\n  input.deltaX = prevDelta.x + (center.x - offset.x);\r\n  input.deltaY = prevDelta.y + (center.y - offset.y);\r\n}\r\n","import { PROPS_CLIENT_XY } from './input-consts';\r\nimport getDistance from './get-distance';\r\n/**\r\n * @private\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nexport default function getScale(start, end) {\r\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n","import getAngle from './get-angle';\r\nimport { PROPS_CLIENT_XY } from './input-consts';\r\n\r\n/**\r\n * @private\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nexport default function getRotation(start, end) {\r\n  let startSorted = start[0].identifier < start[1].identifier;\r\n  let start0 = startSorted ? start[0] : start[1];\r\n  let start1 = startSorted ? start[1] : start[0];\r\n  let endSorted = end[0].identifier < end[1].identifier;\r\n  let end0 = endSorted ? end[0] : end[1];\r\n  let end1 = endSorted ? end[1] : end[0];\r\n  return getAngle(end0, end1, PROPS_CLIENT_XY) - getAngle(start0, start1, PROPS_CLIENT_XY);\r\n}\r\n","import { INPUT_CANCEL,COMPUTE_INTERVAL } from './input-consts';\r\nimport { abs } from '../utils/utils-consts';\r\nimport getVelocity from './get-velocity';\r\nimport getDirection from './get-direction';\r\n\r\n/**\r\n * @private\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nexport default function computeIntervalInputData(session, input) {\r\n  let last = session.lastInterval || input;\r\n  let deltaTime = input.timeStamp - last.timeStamp;\r\n  let velocity;\r\n  let velocityX;\r\n  let velocityY;\r\n  let direction;\r\n\r\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n    let deltaX = input.deltaX - last.deltaX;\r\n    let deltaY = input.deltaY - last.deltaY;\r\n\r\n    let v = getVelocity(deltaTime, deltaX, deltaY);\r\n    velocityX = v.x;\r\n    velocityY = v.y;\r\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\r\n    direction = getDirection(deltaX, deltaY);\r\n\r\n    session.lastInterval = input;\r\n  } else {\r\n    // use latest velocity info if it doesn't overtake a minimum period\r\n    velocity = last.velocity;\r\n    velocityX = last.velocityX;\r\n    velocityY = last.velocityY;\r\n    direction = last.direction;\r\n  }\r\n\r\n  input.velocity = velocity;\r\n  input.velocityX = velocityX;\r\n  input.velocityY = velocityY;\r\n  input.direction = direction;\r\n}\r\n","import { INPUT_START,INPUT_END,INPUT_CANCEL } from './input-consts';\r\nimport computeInputData from './compute-input-data';\r\n\r\n/**\r\n * @private\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nexport default function inputHandler(manager, eventType, input) {\r\n  let pointersLen = input.pointers.length;\r\n  let changedPointersLen = input.changedPointers.length;\r\n  let isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n  let isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\r\n\r\n  input.isFirst = !!isFirst;\r\n  input.isFinal = !!isFinal;\r\n\r\n  if (isFirst) {\r\n    manager.session = {};\r\n  }\r\n\r\n  // source event is the normalized value of the domEvents\r\n  // like 'touchstart, mouseup, pointerdown'\r\n  input.eventType = eventType;\r\n\r\n  // compute scale, rotation etc\r\n  computeInputData(manager, input);\r\n\r\n  // emit secret event\r\n  manager.emit('hammer.input', input);\r\n\r\n  manager.recognize(input);\r\n  manager.session.prevInput = input;\r\n}\r\n","/**\r\n * @private\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\n\r\nexport default function splitStr(str) {\r\n  return str.trim().split(/\\s+/g);\r\n}\r\n","import each from './each';\r\nimport splitStr from './split-str';\r\n/**\r\n * @private\r\n * addEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nexport default function addEventListeners(target, types, handler) {\r\n  each(splitStr(types), (type) => {\r\n    target.addEventListener(type, handler, false);\r\n  });\r\n}\r\n","import each from './each';\r\nimport splitStr from './split-str';\r\n/**\r\n * @private\r\n * removeEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nexport default function removeEventListeners(target, types, handler) {\r\n  each(splitStr(types), (type) => {\r\n    target.removeEventListener(type, handler, false);\r\n  });\r\n}\r\n","/**\r\n * @private\r\n * get the window object of an element\r\n * @param {HTMLElement} element\r\n * @returns {DocumentView|Window}\r\n */\r\nexport default function getWindowForElement(element) {\r\n  let doc = element.ownerDocument || element;\r\n  return (doc.defaultView || doc.parentWindow || window);\r\n}\r\n","import boolOrFn from '../utils/bool-or-fn';\r\nimport addEventListeners from '../utils/add-event-listeners';\r\nimport removeEventListeners from '../utils/remove-event-listeners';\r\nimport getWindowForElement from '../utils/get-window-for-element';\r\n\r\n/**\r\n * @private\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nexport default class Input {\r\n  constructor(manager, callback) {\r\n    let self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n    this.element = manager.element;\r\n    this.target = manager.options.inputTarget;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n      if (boolOrFn(manager.options.enable, [manager])) {\r\n        self.handler(ev);\r\n      }\r\n    };\r\n\r\n    this.init();\r\n\r\n  }\r\n  /**\r\n   * @private\r\n   * should handle the inputEvent data and trigger the callback\r\n   * @virtual\r\n   */\r\n  handler() { }\r\n\r\n  /**\r\n   * @private\r\n   * bind the events\r\n   */\r\n  init() {\r\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\r\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\r\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * unbind the events\r\n   */\r\n  destroy() {\r\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\r\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\r\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n  }\r\n}\r\n","/**\r\n * @private\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nexport default function inArray(src, find, findByKey) {\r\n  if (src.indexOf && !findByKey) {\r\n    return src.indexOf(find);\r\n  } else {\r\n    let i = 0;\r\n    while (i < src.length) {\r\n      if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {// do not use === here, test fails\r\n        return i;\r\n      }\r\n      i++;\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n","import {\r\n    INPUT_START,\r\n    INPUT_END,\r\n    INPUT_CANCEL,\r\n    INPUT_MOVE,\r\n    INPUT_TYPE_TOUCH,\r\n    INPUT_TYPE_MOUSE,\r\n    INPUT_TYPE_PEN,\r\n    INPUT_TYPE_KINECT\r\n} from '../inputjs/input-consts';\r\nimport {window} from \"../browser\";\r\nimport Input from '../inputjs/input-constructor';\r\nimport inArray from '../utils/in-array';\r\n\r\nconst POINTER_INPUT_MAP = {\r\n  pointerdown: INPUT_START,\r\n  pointermove: INPUT_MOVE,\r\n  pointerup: INPUT_END,\r\n  pointercancel: INPUT_CANCEL,\r\n  pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nconst IE10_POINTER_TYPE_ENUM = {\r\n  2: INPUT_TYPE_TOUCH,\r\n  3: INPUT_TYPE_PEN,\r\n  4: INPUT_TYPE_MOUSE,\r\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\r\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent && !window.PointerEvent) {\r\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\r\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\r\n}\r\n\r\n/**\r\n * @private\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nexport default class PointerEventInput extends Input {\r\n  constructor() {\r\n    var proto = PointerEventInput.prototype;\r\n\r\n    proto.evEl = POINTER_ELEMENT_EVENTS;\r\n    proto.evWin = POINTER_WINDOW_EVENTS;\r\n    super(...arguments);\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * handle mouse events\r\n   * @param {Object} ev\r\n   */\r\n  handler(ev) {\r\n    let { store } = this;\r\n    let removePointer = false;\r\n\r\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n    let isTouch = (pointerType === INPUT_TYPE_TOUCH);\r\n\r\n    // get index of the event in the store\r\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\r\n    // start and mouse must be down\r\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\r\n      if (storeIndex < 0) {\r\n        store.push(ev);\r\n        storeIndex = store.length - 1;\r\n      }\r\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n      removePointer = true;\r\n    }\r\n\r\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n    if (storeIndex < 0) {\r\n      return;\r\n    }\r\n\r\n    // update the event in the store\r\n    store[storeIndex] = ev;\r\n\r\n    this.callback(this.manager, eventType, {\r\n      pointers: store,\r\n      changedPointers: [ev],\r\n      pointerType,\r\n      srcEvent: ev\r\n    });\r\n\r\n    if (removePointer) {\r\n      // remove from the store\r\n      store.splice(storeIndex, 1);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @private\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nexport default function toArray(obj) {\r\n  return Array.prototype.slice.call(obj, 0);\r\n}\r\n","import inArray from './in-array';\r\n\r\n/**\r\n * @private\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @param {Boolean} [sort=False]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nexport default function uniqueArray(src, key, sort) {\r\n  let results = [];\r\n  let values = [];\r\n  let i = 0;\r\n\r\n  while (i < src.length) {\r\n    let val = key ? src[i][key] : src[i];\r\n    if (inArray(values, val) < 0) {\r\n      results.push(src[i]);\r\n    }\r\n    values[i] = val;\r\n    i++;\r\n  }\r\n\r\n  if (sort) {\r\n    if (!key) {\r\n      results = results.sort();\r\n    } else {\r\n      results = results.sort((a, b) => {\r\n        return a[key] > b[key];\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n","import {\r\n  INPUT_START,\r\n  INPUT_MOVE,\r\n  INPUT_END,\r\n  INPUT_CANCEL,\r\n  INPUT_TYPE_TOUCH\r\n} from '../inputjs/input-consts';\r\nimport Input from '../inputjs/input-constructor';\r\nimport toArray from '../utils/to-array';\r\nimport hasParent from '../utils/has-parent';\r\nimport uniqueArray from '../utils/unique-array';\r\n\r\nconst TOUCH_INPUT_MAP = {\r\n  touchstart: INPUT_START,\r\n  touchmove: INPUT_MOVE,\r\n  touchend: INPUT_END,\r\n  touchcancel: INPUT_CANCEL\r\n};\r\n\r\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * @private\r\n * Multi-user touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nexport default class TouchInput extends Input {\r\n  constructor() {\r\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\r\n    super(...arguments);\r\n    this.targetIds = {};\r\n    // this.evTarget = TOUCH_TARGET_EVENTS;\r\n  }\r\n  handler(ev) {\r\n    let type = TOUCH_INPUT_MAP[ev.type];\r\n    let touches = getTouches.call(this, ev, type);\r\n    if (!touches) {\r\n      return;\r\n    }\r\n\r\n    this.callback(this.manager, type, {\r\n      pointers: touches[0],\r\n      changedPointers: touches[1],\r\n      pointerType: INPUT_TYPE_TOUCH,\r\n      srcEvent: ev\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction getTouches(ev, type) {\r\n  let allTouches = toArray(ev.touches);\r\n  let { targetIds } = this;\r\n\r\n  // when there is only one touch, the process can be simplified\r\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\r\n    targetIds[allTouches[0].identifier] = true;\r\n    return [allTouches, allTouches];\r\n  }\r\n\r\n  let i;\r\n  let targetTouches;\r\n  let changedTouches = toArray(ev.changedTouches);\r\n  let changedTargetTouches = [];\r\n  let { target } = this;\r\n\r\n  // get target touches from touches\r\n  targetTouches = allTouches.filter((touch) => {\r\n    return hasParent(touch.target, target);\r\n  });\r\n\r\n  // collect touches\r\n  if (type === INPUT_START) {\r\n    i = 0;\r\n    while (i < targetTouches.length) {\r\n      targetIds[targetTouches[i].identifier] = true;\r\n      i++;\r\n    }\r\n  }\r\n\r\n  // filter changed touches to only contain touches that exist in the collected target ids\r\n  i = 0;\r\n  while (i < changedTouches.length) {\r\n    if (targetIds[changedTouches[i].identifier]) {\r\n      changedTargetTouches.push(changedTouches[i]);\r\n    }\r\n\r\n    // cleanup removed touches\r\n    if (type & (INPUT_END | INPUT_CANCEL)) {\r\n      delete targetIds[changedTouches[i].identifier];\r\n    }\r\n    i++;\r\n  }\r\n\r\n  if (!changedTargetTouches.length) {\r\n    return;\r\n  }\r\n\r\n  return [\r\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\r\n    changedTargetTouches\r\n  ];\r\n}\r\n","import {\r\n    INPUT_START,\r\n    INPUT_MOVE,\r\n    INPUT_END,\r\n    INPUT_TYPE_MOUSE\r\n} from '../inputjs/input-consts';\r\nimport Input from '../inputjs/input-constructor';\r\n\r\nconst MOUSE_INPUT_MAP = {\r\n  mousedown: INPUT_START,\r\n  mousemove: INPUT_MOVE,\r\n  mouseup: INPUT_END\r\n};\r\n\r\nconst MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nconst MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\r\n\r\n/**\r\n * @private\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nexport default class MouseInput extends Input {\r\n  constructor() {\r\n    var proto = MouseInput.prototype;\r\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\r\n    proto.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    super(...arguments);\r\n    this.pressed = false; // mousedown state\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * handle mouse events\r\n   * @param {Object} ev\r\n   */\r\n  handler(ev) {\r\n    let eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n    // on start we want to have the left mouse button down\r\n    if (eventType & INPUT_START && ev.button === 0) {\r\n      this.pressed = true;\r\n    }\r\n\r\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n      eventType = INPUT_END;\r\n    }\r\n\r\n    // mouse must be down\r\n    if (!this.pressed) {\r\n      return;\r\n    }\r\n\r\n    if (eventType & INPUT_END) {\r\n      this.pressed = false;\r\n    }\r\n\r\n    this.callback(this.manager, eventType, {\r\n      pointers: [ev],\r\n      changedPointers: [ev],\r\n      pointerType: INPUT_TYPE_MOUSE,\r\n      srcEvent: ev\r\n    });\r\n  }\r\n}\r\n","import Input from \"../inputjs/input-constructor\";\r\nimport TouchInput from \"./touch\";\r\nimport MouseInput from \"./mouse\";\r\nimport {\r\n\tINPUT_START,\r\n\tINPUT_END,\r\n\tINPUT_CANCEL,\r\n\tINPUT_TYPE_TOUCH,\r\n\tINPUT_TYPE_MOUSE,\r\n} from \"../inputjs/input-consts\";\r\n\r\n/**\r\n * @private\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\n\r\nconst DEDUP_TIMEOUT = 2500;\r\nconst DEDUP_DISTANCE = 25;\r\n\r\nfunction setLastTouch(eventData) {\r\n\tconst { changedPointers: [touch] } = eventData;\r\n\r\n\tif (touch.identifier === this.primaryTouch) {\r\n\t\tconst lastTouch = { x: touch.clientX, y: touch.clientY };\r\n\t\tconst lts = this.lastTouches;\r\n\r\n\t\tthis.lastTouches.push(lastTouch);\r\n\r\n\r\n\t\tconst removeLastTouch = function() {\r\n\t\t\tconst i = lts.indexOf(lastTouch);\r\n\r\n\t\t\tif (i > -1) {\r\n\t\t\t\tlts.splice(i, 1);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tsetTimeout(removeLastTouch, DEDUP_TIMEOUT);\r\n\t}\r\n}\r\n\r\n\r\nfunction recordTouches(eventType, eventData) {\r\n\tif (eventType & INPUT_START) {\r\n\t\tthis.primaryTouch = eventData.changedPointers[0].identifier;\r\n\t\tsetLastTouch.call(this, eventData);\r\n\t} else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t\tsetLastTouch.call(this, eventData);\r\n\t}\r\n}\r\nfunction isSyntheticEvent(eventData) {\r\n\tconst x = eventData.srcEvent.clientX;\r\n\tconst y = eventData.srcEvent.clientY;\r\n\r\n\tfor (let i = 0; i < this.lastTouches.length; i++) {\r\n\t\tconst t = this.lastTouches[i];\r\n\t\tconst dx = Math.abs(x - t.x);\r\n\t\tconst dy = Math.abs(y - t.y);\r\n\r\n\t\tif (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\nexport default class TouchMouseInput extends Input {\r\n\tconstructor(manager, callback) {\r\n\t\tsuper(manager, callback);\r\n\r\n\t\tthis.touch = new TouchInput(this.manager, this.handler);\r\n\t\tthis.mouse = new MouseInput(this.manager, this.handler);\r\n\t\tthis.primaryTouch = null;\r\n\t\tthis.lastTouches = [];\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * handle mouse and touch events\r\n\t * @param {Hammer} manager\r\n\t * @param {String} inputEvent\r\n\t * @param {Object} inputData\r\n\t */\r\n\thandler = (manager, inputEvent, inputData) => {\r\n\t\tconst isTouch = (inputData.pointerType === INPUT_TYPE_TOUCH);\r\n\t\tconst isMouse = (inputData.pointerType === INPUT_TYPE_MOUSE);\r\n\r\n\t\tif (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// when we're in a touch event, record touches to  de-dupe synthetic mouse event\r\n\t\tif (isTouch) {\r\n\t\t\trecordTouches.call(this, inputEvent, inputData);\r\n\t\t} else if (isMouse && isSyntheticEvent.call(this, inputData)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.callback(manager, inputEvent, inputData);\r\n\t}\r\n\r\n\t/**\r\n\t * @private\r\n\t * remove the event listeners\r\n\t */\r\n\tdestroy() {\r\n\t\tthis.touch.destroy();\r\n\t\tthis.mouse.destroy();\r\n\t}\r\n}\r\n","import each from './each';\r\n/**\r\n * @private\r\n * if the argument is an array, we want to execute the fn on each entry\r\n * if it aint an array we don't want to do a thing.\r\n * this is used by all the methods that accept a single and array argument.\r\n * @param {*|Array} arg\r\n * @param {String} fn\r\n * @param {Object} [context]\r\n * @returns {Boolean}\r\n */\r\nexport default function invokeArrayArg(arg, fn, context) {\r\n  if (Array.isArray(arg)) {\r\n    each(arg, context[fn], context);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n","const STATE_POSSIBLE = 1;\r\nconst STATE_BEGAN = 2;\r\nconst STATE_CHANGED = 4;\r\nconst STATE_ENDED = 8;\r\nconst STATE_RECOGNIZED = STATE_ENDED;\r\nconst STATE_CANCELLED = 16;\r\nconst STATE_FAILED = 32;\r\n\r\nexport {\r\n    STATE_POSSIBLE,\r\n    STATE_BEGAN,\r\n    STATE_CHANGED,\r\n    STATE_ENDED,\r\n    STATE_RECOGNIZED,\r\n    STATE_CANCELLED,\r\n    STATE_FAILED\r\n};\r\n","/**\r\n * @private\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nlet _uniqueId = 1;\r\nexport default function uniqueId() {\r\n  return _uniqueId++;\r\n}\r\n","/**\r\n * @private\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nexport default function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n  let { manager } = recognizer;\r\n  if (manager) {\r\n    return manager.get(otherRecognizer);\r\n  }\r\n  return otherRecognizer;\r\n}\r\n","import {\r\n    STATE_CANCELLED,\r\n    STATE_ENDED,\r\n    STATE_CHANGED,\r\n    STATE_BEGAN\r\n} from './recognizer-consts';\r\n\r\n/**\r\n * @private\r\n * get a usable string, used as event postfix\r\n * @param {constant} state\r\n * @returns {String} state\r\n */\r\nexport default function stateStr(state) {\r\n  if (state & STATE_CANCELLED) {\r\n    return 'cancel';\r\n  } else if (state & STATE_ENDED) {\r\n    return 'end';\r\n  } else if (state & STATE_CHANGED) {\r\n    return 'move';\r\n  } else if (state & STATE_BEGAN) {\r\n    return 'start';\r\n  }\r\n  return '';\r\n}\r\n","import {\r\n    STATE_POSSIBLE,\r\n    STATE_ENDED,\r\n    STATE_FAILED,\r\n    STATE_RECOGNIZED,\r\n    STATE_CANCELLED,\r\n    STATE_BEGAN,\r\n    STATE_CHANGED\r\n} from './recognizer-consts';\r\nimport assign from '../utils/assign';\r\nimport uniqueId from '../utils/unique-id';\r\nimport invokeArrayArg from '../utils/invoke-array-arg';\r\nimport inArray from '../utils/in-array';\r\nimport boolOrFn from '../utils/bool-or-fn';\r\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\r\nimport stateStr from './state-str';\r\n\r\n/**\r\n * @private\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\n\r\n/**\r\n * @private\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nexport default class Recognizer {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      enable: true,\r\n      ...options,\r\n    };\r\n\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n\r\n    // default is enable true\r\n    this.state = STATE_POSSIBLE;\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * set options\r\n   * @param {Object} options\r\n   * @return {Recognizer}\r\n   */\r\n  set(options) {\r\n    assign(this.options, options);\r\n\r\n    // also update the touchAction, in case something changed about the directions/enabled state\r\n    this.manager && this.manager.touchAction.update();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * recognize simultaneous with an other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n  recognizeWith(otherRecognizer) {\r\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\r\n      return this;\r\n    }\r\n\r\n    let { simultaneous } = this;\r\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n    if (!simultaneous[otherRecognizer.id]) {\r\n      simultaneous[otherRecognizer.id] = otherRecognizer;\r\n      otherRecognizer.recognizeWith(this);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n  dropRecognizeWith(otherRecognizer) {\r\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\r\n      return this;\r\n    }\r\n\r\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n    delete this.simultaneous[otherRecognizer.id];\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * recognizer can only run when an other is failing\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n  requireFailure(otherRecognizer) {\r\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\r\n      return this;\r\n    }\r\n\r\n    let { requireFail } = this;\r\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n    if (inArray(requireFail, otherRecognizer) === -1) {\r\n      requireFail.push(otherRecognizer);\r\n      otherRecognizer.requireFailure(this);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n  dropRequireFailure(otherRecognizer) {\r\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\r\n      return this;\r\n    }\r\n\r\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n    let index = inArray(this.requireFail, otherRecognizer);\r\n    if (index > -1) {\r\n      this.requireFail.splice(index, 1);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * has require failures boolean\r\n   * @returns {boolean}\r\n   */\r\n  hasRequireFailures() {\r\n    return this.requireFail.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * if the recognizer can recognize simultaneous with an other recognizer\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Boolean}\r\n   */\r\n  canRecognizeWith(otherRecognizer) {\r\n    return !!this.simultaneous[otherRecognizer.id];\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * You should use `tryEmit` instead of `emit` directly to check\r\n   * that all the needed recognizers has failed before emitting.\r\n   * @param {Object} input\r\n   */\r\n  emit(input) {\r\n    let self = this;\r\n    let { state } = this;\r\n\r\n    function emit(event) {\r\n      self.manager.emit(event, input);\r\n    }\r\n\r\n    // 'panstart' and 'panmove'\r\n    if (state < STATE_ENDED) {\r\n      emit(self.options.event + stateStr(state));\r\n    }\r\n\r\n    emit(self.options.event); // simple 'eventName' events\r\n\r\n    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\r\n      emit(input.additionalEvent);\r\n    }\r\n\r\n    // panend and pancancel\r\n    if (state >= STATE_ENDED) {\r\n      emit(self.options.event + stateStr(state));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Check that all the require failure recognizers has failed,\r\n   * if true, it emits a gesture event,\r\n   * otherwise, setup the state to FAILED.\r\n   * @param {Object} input\r\n   */\r\n  tryEmit(input) {\r\n    if (this.canEmit()) {\r\n      return this.emit(input);\r\n    }\r\n    // it's failing anyway\r\n    this.state = STATE_FAILED;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * can we emit?\r\n   * @returns {boolean}\r\n   */\r\n  canEmit() {\r\n    let i = 0;\r\n    while (i < this.requireFail.length) {\r\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n        return false;\r\n      }\r\n      i++;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * update the recognizer\r\n   * @param {Object} inputData\r\n   */\r\n  recognize(inputData) {\r\n    // make a new copy of the inputData\r\n    // so we can change the inputData without messing up the other recognizers\r\n    let inputDataClone = assign({}, inputData);\r\n\r\n    // is is enabled and allow recognizing?\r\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n      this.reset();\r\n      this.state = STATE_FAILED;\r\n      return;\r\n    }\r\n\r\n    // reset when we've reached the end\r\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n      this.state = STATE_POSSIBLE;\r\n    }\r\n\r\n    this.state = this.process(inputDataClone);\r\n\r\n    // the recognizer has recognized a gesture\r\n    // so trigger an event\r\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n      this.tryEmit(inputDataClone);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * return the state of the recognizer\r\n   * the actual recognizing happens in this method\r\n   * @virtual\r\n   * @param {Object} inputData\r\n   * @returns {constant} STATE\r\n   */\r\n\r\n  /* jshint ignore:start */\r\n  process(inputData) { }\r\n  /* jshint ignore:end */\r\n\r\n  /**\r\n   * @private\r\n   * return the preferred touch-action\r\n   * @virtual\r\n   * @returns {Array}\r\n   */\r\n  getTouchAction() { }\r\n\r\n  /**\r\n   * @private\r\n   * called when the gesture isn't allowed to recognize\r\n   * like when another is being recognized or it is disabled\r\n   * @virtual\r\n   */\r\n  reset() { }\r\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\r\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\r\nimport {INPUT_START,INPUT_END } from '../inputjs/input-consts';\r\nimport {\r\n    STATE_RECOGNIZED,\r\n    STATE_BEGAN,\r\n    STATE_FAILED\r\n} from '../recognizerjs/recognizer-consts';\r\nimport getDistance from '../inputjs/get-distance';\r\n\r\n/**\r\n * @private\r\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nexport default class TapRecognizer extends Recognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      event: 'tap',\r\n      pointers: 1,\r\n      taps: 1,\r\n      interval: 300, // max time between the multi-tap taps\r\n      time: 250, // max time of the pointer to be down (like finger on the screen)\r\n      threshold: 9, // a minimal movement is ok, but keep it low\r\n      posThreshold: 10, // a multi-tap can be a bit off the initial position\r\n      ...options,\r\n    });\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [TOUCH_ACTION_MANIPULATION];\r\n  }\r\n\r\n  process(input) {\r\n    let { options } = this;\r\n\r\n    let validPointers = input.pointers.length === options.pointers;\r\n    let validMovement = input.distance < options.threshold;\r\n    let validTouchTime = input.deltaTime < options.time;\r\n\r\n    this.reset();\r\n\r\n    if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n      return this.failTimeout();\r\n    }\r\n\r\n    // we only allow little movement\r\n    // and we've reached an end event, so a tap is possible\r\n    if (validMovement && validTouchTime && validPointers) {\r\n      if (input.eventType !== INPUT_END) {\r\n        return this.failTimeout();\r\n      }\r\n\r\n      let validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n      let validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n      this.pTime = input.timeStamp;\r\n      this.pCenter = input.center;\r\n\r\n      if (!validMultiTap || !validInterval) {\r\n        this.count = 1;\r\n      } else {\r\n        this.count += 1;\r\n      }\r\n\r\n      this._input = input;\r\n\r\n      // if tap count matches we have recognized it,\r\n      // else it has began recognizing...\r\n      let tapCount = this.count % options.taps;\r\n      if (tapCount === 0) {\r\n        // no failing requirements, immediately trigger the tap event\r\n        // or wait as long as the multitap interval to trigger\r\n        if (!this.hasRequireFailures()) {\r\n          return STATE_RECOGNIZED;\r\n        } else {\r\n          this._timer = setTimeout(() => {\r\n            this.state = STATE_RECOGNIZED;\r\n            this.tryEmit();\r\n          }, options.interval);\r\n          return STATE_BEGAN;\r\n        }\r\n      }\r\n    }\r\n    return STATE_FAILED;\r\n  }\r\n\r\n  failTimeout() {\r\n    this._timer = setTimeout(() => {\r\n      this.state = STATE_FAILED;\r\n    }, this.options.interval);\r\n    return STATE_FAILED;\r\n  }\r\n\r\n  reset() {\r\n    clearTimeout(this._timer);\r\n  }\r\n\r\n  emit() {\r\n    if (this.state === STATE_RECOGNIZED) {\r\n      this._input.tapCount = this.count;\r\n      this.manager.emit(this.options.event, this._input);\r\n    }\r\n  }\r\n}\r\n","import Recognizer from '../recognizerjs/recognizer-constructor';\r\nimport {\r\n    STATE_BEGAN,\r\n    STATE_CHANGED,\r\n    STATE_CANCELLED,\r\n    STATE_ENDED,\r\n    STATE_FAILED\r\n} from '../recognizerjs/recognizer-consts';\r\nimport {\r\n    INPUT_CANCEL,\r\n    INPUT_END\r\n} from '../inputjs/input-consts';\r\n\r\n/**\r\n * @private\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nexport default class AttrRecognizer extends Recognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      pointers: 1,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n   * @memberof AttrRecognizer\r\n   * @param {Object} input\r\n   * @returns {Boolean} recognized\r\n   */\r\n  attrTest(input) {\r\n    let optionPointers = this.options.pointers;\r\n    return optionPointers === 0 || input.pointers.length === optionPointers;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Process the input and return the state for the recognizer\r\n   * @memberof AttrRecognizer\r\n   * @param {Object} input\r\n   * @returns {*} State\r\n   */\r\n  process(input) {\r\n    let { state } = this;\r\n    let { eventType } = input;\r\n\r\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n    let isValid = this.attrTest(input);\r\n\r\n    // on cancel input and we've recognized before, return STATE_CANCELLED\r\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n      return state | STATE_CANCELLED;\r\n    } else if (isRecognized || isValid) {\r\n      if (eventType & INPUT_END) {\r\n        return state | STATE_ENDED;\r\n      } else if (!(state & STATE_BEGAN)) {\r\n        return STATE_BEGAN;\r\n      }\r\n      return state | STATE_CHANGED;\r\n    }\r\n    return STATE_FAILED;\r\n  }\r\n}\r\n","import {\r\n    DIRECTION_LEFT,\r\n    DIRECTION_RIGHT,\r\n    DIRECTION_UP,\r\n    DIRECTION_DOWN\r\n} from '../inputjs/input-consts';\r\n\r\n/**\r\n * @private\r\n * direction cons to string\r\n * @param {constant} direction\r\n * @returns {String}\r\n */\r\nexport default function directionStr(direction) {\r\n  if (direction === DIRECTION_DOWN) {\r\n    return 'down';\r\n  } else if (direction === DIRECTION_UP) {\r\n    return 'up';\r\n  } else if (direction === DIRECTION_LEFT) {\r\n    return 'left';\r\n  } else if (direction === DIRECTION_RIGHT) {\r\n    return 'right';\r\n  }\r\n  return '';\r\n}\r\n","import  AttrRecognizer from './attribute';\r\nimport {\r\n    DIRECTION_ALL,\r\n    DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL,\r\n    DIRECTION_NONE,\r\n    DIRECTION_UP,\r\n    DIRECTION_DOWN,\r\n    DIRECTION_LEFT,\r\n    DIRECTION_RIGHT\r\n} from '../inputjs/input-consts';\r\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\r\nimport { TOUCH_ACTION_PAN_X,TOUCH_ACTION_PAN_Y } from '../touchactionjs/touchaction-Consts';\r\nimport directionStr from '../recognizerjs/direction-str';\r\n\r\n/**\r\n * @private\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nexport default class PanRecognizer extends AttrRecognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      event: 'pan',\r\n      threshold: 10,\r\n      pointers: 1,\r\n      direction: DIRECTION_ALL,\r\n      ...options,\r\n    });\r\n    this.pX = null;\r\n    this.pY = null;\r\n  }\r\n\r\n  getTouchAction() {\r\n    let { options:{ direction } } = this;\r\n    let actions = [];\r\n    if (direction & DIRECTION_HORIZONTAL) {\r\n      actions.push(TOUCH_ACTION_PAN_Y);\r\n    }\r\n    if (direction & DIRECTION_VERTICAL) {\r\n      actions.push(TOUCH_ACTION_PAN_X);\r\n    }\r\n    return actions;\r\n  }\r\n\r\n  directionTest(input) {\r\n    let { options } = this;\r\n    let hasMoved = true;\r\n    let { distance } = input;\r\n    let { direction } = input;\r\n    let x = input.deltaX;\r\n    let y = input.deltaY;\r\n\r\n    // lock to axis?\r\n    if (!(direction & options.direction)) {\r\n      if (options.direction & DIRECTION_HORIZONTAL) {\r\n        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n        hasMoved = x !== this.pX;\r\n        distance = Math.abs(input.deltaX);\r\n      } else {\r\n        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n        hasMoved = y !== this.pY;\r\n        distance = Math.abs(input.deltaY);\r\n      }\r\n    }\r\n    input.direction = direction;\r\n    return hasMoved && distance > options.threshold && direction & options.direction;\r\n  }\r\n\r\n  attrTest(input) {\r\n    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\r\n        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n  }\r\n\r\n  emit(input) {\r\n\r\n    this.pX = input.deltaX;\r\n    this.pY = input.deltaY;\r\n\r\n    let direction = directionStr(input.direction);\r\n\r\n    if (direction) {\r\n      input.additionalEvent = this.options.event + direction;\r\n    }\r\n    super.emit(input);\r\n  }\r\n}\r\n","import AttrRecognizer from '../recognizers/attribute';\r\nimport { abs } from '../utils/utils-consts';\r\nimport { DIRECTION_HORIZONTAL,DIRECTION_VERTICAL } from '../inputjs/input-consts';\r\nimport PanRecognizer from './pan';\r\nimport { INPUT_END } from '../inputjs/input-consts';\r\nimport directionStr from '../recognizerjs/direction-str';\r\n\r\n/**\r\n * @private\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nexport default class SwipeRecognizer extends AttrRecognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      event: 'swipe',\r\n      threshold: 10,\r\n      velocity: 0.3,\r\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n      pointers: 1,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  getTouchAction() {\r\n    return PanRecognizer.prototype.getTouchAction.call(this);\r\n  }\r\n\r\n  attrTest(input) {\r\n    let { direction } = this.options;\r\n    let velocity;\r\n\r\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n      velocity = input.overallVelocity;\r\n    } else if (direction & DIRECTION_HORIZONTAL) {\r\n      velocity = input.overallVelocityX;\r\n    } else if (direction & DIRECTION_VERTICAL) {\r\n      velocity = input.overallVelocityY;\r\n    }\r\n\r\n    return super.attrTest(input) &&\r\n        direction & input.offsetDirection &&\r\n        input.distance > this.options.threshold &&\r\n        input.maxPointers === this.options.pointers &&\r\n        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\r\n  }\r\n\r\n  emit(input) {\r\n    let direction = directionStr(input.offsetDirection);\r\n    if (direction) {\r\n      this.manager.emit(this.options.event + direction, input);\r\n    }\r\n\r\n    this.manager.emit(this.options.event, input);\r\n  }\r\n}\r\n","import AttrRecognizer from './attribute';\r\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\r\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\r\n\r\n/**\r\n * @private\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nexport default class PinchRecognizer extends AttrRecognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      event: 'pinch',\r\n      threshold: 0,\r\n      pointers: 2,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [TOUCH_ACTION_NONE];\r\n  }\r\n\r\n  attrTest(input) {\r\n    return super.attrTest(input) &&\r\n        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n  }\r\n\r\n  emit(input) {\r\n    if (input.scale !== 1) {\r\n      let inOut = input.scale < 1 ? 'in' : 'out';\r\n      input.additionalEvent = this.options.event + inOut;\r\n    }\r\n    super.emit(input);\r\n  }\r\n}\r\n","import AttrRecognizer from './attribute';\r\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\r\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\r\n\r\n/**\r\n * @private\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nexport default class RotateRecognizer extends AttrRecognizer {\r\n  constructor(options = {}) {\r\n    super( {\r\n      event: 'rotate',\r\n      threshold: 0,\r\n      pointers: 2,\r\n      ...options,\r\n    });\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [TOUCH_ACTION_NONE];\r\n  }\r\n\r\n  attrTest(input) {\r\n    return super.attrTest(input) &&\r\n        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n  }\r\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\r\nimport {\r\n    STATE_RECOGNIZED,\r\n    STATE_FAILED\r\n} from '../recognizerjs/recognizer-consts';\r\nimport { now } from '../utils/utils-consts';\r\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\r\nimport {\r\n    INPUT_START,\r\n    INPUT_END,\r\n    INPUT_CANCEL\r\n} from '../inputjs/input-consts';\r\n\r\n/**\r\n * @private\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nexport default class PressRecognizer extends Recognizer {\r\n  constructor(options = {}) {\r\n    super({\r\n      event: 'press',\r\n      pointers: 1,\r\n      time: 251, // minimal time of the pointer to be pressed\r\n      threshold: 9, // a minimal movement is ok, but keep it low\r\n      ...options,\r\n    });\r\n    this._timer = null;\r\n    this._input = null;\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [TOUCH_ACTION_AUTO];\r\n  }\r\n\r\n  process(input) {\r\n    let { options } = this;\r\n    let validPointers = input.pointers.length === options.pointers;\r\n    let validMovement = input.distance < options.threshold;\r\n    let validTime = input.deltaTime > options.time;\r\n\r\n    this._input = input;\r\n\r\n    // we only allow little movement\r\n    // and we've reached an end event, so a tap is possible\r\n    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n      this.reset();\r\n    } else if (input.eventType & INPUT_START) {\r\n      this.reset();\r\n      this._timer = setTimeout(() => {\r\n        this.state = STATE_RECOGNIZED;\r\n        this.tryEmit();\r\n      }, options.time);\r\n    } else if (input.eventType & INPUT_END) {\r\n      return STATE_RECOGNIZED;\r\n    }\r\n    return STATE_FAILED;\r\n  }\r\n\r\n  reset() {\r\n    clearTimeout(this._timer);\r\n  }\r\n\r\n  emit(input) {\r\n    if (this.state !== STATE_RECOGNIZED) {\r\n      return;\r\n    }\r\n\r\n    if (input && (input.eventType & INPUT_END)) {\r\n      this.manager.emit(`${this.options.event}up`, input);\r\n    } else {\r\n      this._input.timeStamp = now();\r\n      this.manager.emit(this.options.event, this._input);\r\n    }\r\n  }\r\n}\r\n\r\n","import { TOUCH_ACTION_COMPUTE } from \"./touchactionjs/touchaction-Consts\";\r\nimport TapRecognizer from \"./recognizers/tap\";\r\nimport PanRecognizer from \"./recognizers/pan\";\r\nimport SwipeRecognizer from \"./recognizers/swipe\";\r\nimport PinchRecognizer from \"./recognizers/pinch\";\r\nimport RotateRecognizer from \"./recognizers/rotate\";\r\nimport PressRecognizer from \"./recognizers/press\";\r\nimport {DIRECTION_HORIZONTAL} from \"./inputjs/input-consts\";\r\n\r\nexport default {\r\n\t/**\r\n\t * @private\r\n\t * set if DOM events are being triggered.\r\n\t * But this is slower and unused by simple implementations, so disabled by default.\r\n\t * @type {Boolean}\r\n\t * @default false\r\n\t */\r\n\tdomEvents: false,\r\n\r\n\t/**\r\n\t * @private\r\n\t * The value for the touchAction property/fallback.\r\n\t * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n\t * @type {String}\r\n\t * @default compute\r\n\t */\r\n\ttouchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n\t/**\r\n\t * @private\r\n\t * @type {Boolean}\r\n\t * @default true\r\n\t */\r\n\tenable: true,\r\n\r\n\t/**\r\n\t * @private\r\n\t * EXPERIMENTAL FEATURE -- can be removed/changed\r\n\t * Change the parent input target element.\r\n\t * If Null, then it is being set the to main element.\r\n\t * @type {Null|EventTarget}\r\n\t * @default null\r\n\t */\r\n\tinputTarget: null,\r\n\r\n\t/**\r\n\t * @private\r\n\t * force an input class\r\n\t * @type {Null|Function}\r\n\t * @default null\r\n\t */\r\n\tinputClass: null,\r\n\r\n\t/**\r\n\t * @private\r\n\t * Some CSS properties can be used to improve the working of Hammer.\r\n\t * Add them to this method and they will be set when creating a new Manager.\r\n\t * @namespace\r\n\t */\r\n\tcssProps: {\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n\t\t * @type {String}\r\n\t\t * @default 'none'\r\n\t\t */\r\n\t\tuserSelect: \"none\",\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Disable the Windows Phone grippers when pressing an element.\r\n\t\t * @type {String}\r\n\t\t * @default 'none'\r\n\t\t */\r\n\t\ttouchSelect: \"none\",\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Disables the default callout shown when you touch and hold a touch target.\r\n\t\t * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t\t * a callout containing information about the link. This property allows you to disable that callout.\r\n\t\t * @type {String}\r\n\t\t * @default 'none'\r\n\t\t */\r\n\t\ttouchCallout: \"none\",\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Specifies whether zooming is enabled. Used by IE10>\r\n\t\t * @type {String}\r\n\t\t * @default 'none'\r\n\t\t */\r\n\t\tcontentZooming: \"none\",\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t\t * @type {String}\r\n\t\t * @default 'none'\r\n\t\t */\r\n\t\tuserDrag: \"none\",\r\n\r\n\t\t/**\r\n\t\t * @private\r\n\t\t * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t\t * clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t\t * @type {String}\r\n\t\t * @default 'rgba(0,0,0,0)'\r\n\t\t */\r\n\t\ttapHighlightColor: \"rgba(0,0,0,0)\",\r\n\t},\r\n};\r\n\r\n/**\r\n * @private\r\n * Default recognizer setup when calling `Hammer()`\r\n * When creating a new Manager these will be skipped.\r\n * This is separated with other defaults because of tree-shaking.\r\n * @type {Array}\r\n */\r\nexport const preset = [\r\n  [RotateRecognizer, { enable: false }],\r\n  [PinchRecognizer, { enable: false }, ['rotate']],\r\n  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\r\n  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n  [TapRecognizer],\r\n  [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n  [PressRecognizer]\r\n];\r\n","import assign from \"./utils/assign\";\r\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\r\nimport createInputInstance from \"./inputjs/create-input-instance\";\r\nimport each from \"./utils/each\";\r\nimport inArray from \"./utils/in-array\";\r\nimport invokeArrayArg from \"./utils/invoke-array-arg\";\r\nimport splitStr from \"./utils/split-str\";\r\nimport prefixed from \"./utils/prefixed\";\r\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\r\nimport {\r\n  STATE_BEGAN,\r\n  STATE_ENDED,\r\n  STATE_CHANGED,\r\n  STATE_RECOGNIZED,\r\n} from \"./recognizerjs/recognizer-consts\";\r\nimport defaults from \"./defaults\";\r\n\r\nconst STOP = 1;\r\nconst FORCED_STOP = 2;\r\n\r\n\r\n/**\r\n * @private\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n  const { element } = manager;\r\n\r\n  if (!element.style) {\r\n    return;\r\n  }\r\n  let prop;\r\n\r\n  each(manager.options.cssProps, (value, name) => {\r\n    prop = prefixed(element.style, name);\r\n    if (add) {\r\n      manager.oldCssProps[prop] = element.style[prop];\r\n      element.style[prop] = value;\r\n    } else {\r\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\r\n    }\r\n  });\r\n  if (!add) {\r\n    manager.oldCssProps = {};\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n  const gestureEvent = document.createEvent(\"Event\");\r\n\r\n  gestureEvent.initEvent(event, true, true);\r\n  gestureEvent.gesture = data;\r\n  data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\n\r\n/**\r\n* @private\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nexport default class Manager {\r\n  constructor(element, options) {\r\n    this.options = assign({}, defaults, options || {});\r\n\r\n    this.options.inputTarget = this.options.inputTarget || element;\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n    this.oldCssProps = {};\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(this.options.recognizers, item => {\r\n      const recognizer = this.add(new (item[0])(item[1]));\r\n\r\n      item[2] && recognizer.recognizeWith(item[2]);\r\n      item[3] && recognizer.requireFailure(item[3]);\r\n    }, this);\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * set options\r\n\t * @param {Object} options\r\n\t * @returns {Manager}\r\n\t */\r\n  set(options) {\r\n    assign(this.options, options);\r\n\r\n    // Options that need a little more setup\r\n    if (options.touchAction) {\r\n      this.touchAction.update();\r\n    }\r\n    if (options.inputTarget) {\r\n      // Clean up existing event listeners and reinitialize\r\n      this.input.destroy();\r\n      this.input.target = options.inputTarget;\r\n      this.input.init();\r\n    }\r\n    return this;\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * stop recognizing for this session.\r\n\t * This session will be discarded, when a new [input]start event is fired.\r\n\t * When forced, the recognizer cycle is stopped immediately.\r\n\t * @param {Boolean} [force]\r\n\t */\r\n  stop(force) {\r\n    this.session.stopped = force ? FORCED_STOP : STOP;\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * run the recognizers!\r\n\t * called by the inputHandler function on every movement of the pointers (touches)\r\n\t * it walks through all the recognizers and tries to detect the gesture that is being made\r\n\t * @param {Object} inputData\r\n\t */\r\n  recognize(inputData) {\r\n    const { session } = this;\r\n\r\n    if (session.stopped) {\r\n      return;\r\n    }\r\n\r\n    // run the touch-action polyfill\r\n    this.touchAction.preventDefaults(inputData);\r\n\r\n    let recognizer;\r\n    const { recognizers } = this;\r\n\r\n    // this holds the recognizer that is being recognized.\r\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n    // if no recognizer is detecting a thing, it is set to `null`\r\n    let { curRecognizer } = session;\r\n\r\n    // reset when the last recognizer is recognized\r\n    // or when we're in a new session\r\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n      session.curRecognizer = null;\r\n      curRecognizer = null;\r\n    }\r\n\r\n    let i = 0;\r\n\r\n    while (i < recognizers.length) {\r\n      recognizer = recognizers[i];\r\n\r\n      // find out if we are allowed try to recognize the input for this one.\r\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n      //      that is being recognized.\r\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n      if (session.stopped !== FORCED_STOP && (// 1\r\n        !curRecognizer || recognizer === curRecognizer || // 2\r\n        recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n        recognizer.recognize(inputData);\r\n      } else {\r\n        recognizer.reset();\r\n      }\r\n\r\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n      // current active recognizer. but only if we don't already have an active recognizer\r\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n        session.curRecognizer = recognizer;\r\n        curRecognizer = recognizer;\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * get a recognizer by its event name.\r\n\t * @param {Recognizer|String} recognizer\r\n\t * @returns {Recognizer|Null}\r\n\t */\r\n  get(recognizer) {\r\n    if (recognizer instanceof Recognizer) {\r\n      return recognizer;\r\n    }\r\n\r\n    const { recognizers } = this;\r\n\r\n    for (let i = 0; i < recognizers.length; i++) {\r\n      if (recognizers[i].options.event === recognizer) {\r\n        return recognizers[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n\t/**\r\n\t * @private add a recognizer to the manager\r\n\t * existing recognizers with the same event name will be removed\r\n\t * @param {Recognizer} recognizer\r\n\t * @returns {Recognizer|Manager}\r\n\t */\r\n  add(recognizer) {\r\n    if (invokeArrayArg(recognizer, \"add\", this)) {\r\n      return this;\r\n    }\r\n\r\n    // remove existing\r\n    const existing = this.get(recognizer.options.event);\r\n\r\n    if (existing) {\r\n      this.remove(existing);\r\n    }\r\n\r\n    this.recognizers.push(recognizer);\r\n    recognizer.manager = this;\r\n\r\n    this.touchAction.update();\r\n    return recognizer;\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * remove a recognizer by name or instance\r\n\t * @param {Recognizer|String} recognizer\r\n\t * @returns {Manager}\r\n\t */\r\n  remove(recognizer) {\r\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\r\n      return this;\r\n    }\r\n\r\n    const targetRecognizer = this.get(recognizer);\r\n\r\n    // let's make sure this recognizer exists\r\n    if (recognizer) {\r\n      const { recognizers } = this;\r\n      const index = inArray(recognizers, targetRecognizer);\r\n\r\n      if (index !== -1) {\r\n        recognizers.splice(index, 1);\r\n        this.touchAction.update();\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * bind event\r\n\t * @param {String} events\r\n\t * @param {Function} handler\r\n\t * @returns {EventEmitter} this\r\n\t */\r\n  on(events, handler) {\r\n    if (events === undefined || handler === undefined) {\r\n      return this;\r\n    }\r\n\r\n    const { handlers } = this;\r\n\r\n    each(splitStr(events), event => {\r\n      handlers[event] = handlers[event] || [];\r\n      handlers[event].push(handler);\r\n    });\r\n    return this;\r\n  }\r\n\r\n\t/**\r\n\t * @private unbind event, leave emit blank to remove all handlers\r\n\t * @param {String} events\r\n\t * @param {Function} [handler]\r\n\t * @returns {EventEmitter} this\r\n\t */\r\n  off(events, handler) {\r\n    if (events === undefined) {\r\n      return this;\r\n    }\r\n\r\n    const { handlers } = this;\r\n\r\n    each(splitStr(events), event => {\r\n      if (!handler) {\r\n        delete handlers[event];\r\n      } else {\r\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n\r\n\t/**\r\n\t * @private emit event to the listeners\r\n\t * @param {String} event\r\n\t * @param {Object} data\r\n\t */\r\n  emit(event, data) {\r\n    // we also want to trigger dom events\r\n    if (this.options.domEvents) {\r\n      triggerDomEvent(event, data);\r\n    }\r\n\r\n    // no handlers, so skip it all\r\n    const handlers = this.handlers[event] && this.handlers[event].slice();\r\n\r\n    if (!handlers || !handlers.length) {\r\n      return;\r\n    }\r\n\r\n    data.type = event;\r\n    data.preventDefault = function () {\r\n      data.srcEvent.preventDefault();\r\n    };\r\n\r\n    let i = 0;\r\n\r\n    while (i < handlers.length) {\r\n      handlers[i](data);\r\n      i++;\r\n    }\r\n  }\r\n\r\n\t/**\r\n\t * @private\r\n\t * destroy the manager and unbinds all events\r\n\t * it doesn't unbind dom events, that is the user own responsibility\r\n\t */\r\n  destroy() {\r\n    this.element && toggleCssProps(this, false);\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.input.destroy();\r\n    this.element = null;\r\n  }\r\n}\r\n","import { SUPPORT_POINTER_EVENTS,SUPPORT_ONLY_TOUCH,SUPPORT_TOUCH } from './input-consts';\r\nimport inputHandler from './input-handler';\r\nimport PointerEventInput from '../input/pointerevent';\r\nimport TouchInput from '../input/touch';\r\nimport MouseInput from '../input/mouse';\r\nimport TouchMouseInput from '../input/touchmouse';\r\n\r\n/**\r\n * @private\r\n * create new input type manager\r\n * called by the Manager constructor\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nexport default function createInputInstance(manager) {\r\n  let Type;\r\n  // let inputClass = manager.options.inputClass;\r\n  let { options:{ inputClass } } = manager;\r\n  if (inputClass) {\r\n    Type = inputClass;\r\n  } else if (SUPPORT_POINTER_EVENTS) {\r\n    Type = PointerEventInput;\r\n  } else if (SUPPORT_ONLY_TOUCH) {\r\n    Type = TouchInput;\r\n  } else if (!SUPPORT_TOUCH) {\r\n    Type = MouseInput;\r\n  } else {\r\n    Type = TouchMouseInput;\r\n  }\r\n  return new (Type)(manager, inputHandler);\r\n}\r\n","import {\r\n    INPUT_START,\r\n    INPUT_MOVE,\r\n    INPUT_END,\r\n    INPUT_CANCEL,\r\n    INPUT_TYPE_TOUCH\r\n} from '../inputjs/input-consts';\r\nimport Input from '../inputjs/input-constructor';\r\nimport toArray from '../utils/to-array';\r\nimport uniqueArray from '../utils/unique-array';\r\n\r\nconst SINGLE_TOUCH_INPUT_MAP = {\r\n  touchstart: INPUT_START,\r\n  touchmove: INPUT_MOVE,\r\n  touchend: INPUT_END,\r\n  touchcancel: INPUT_CANCEL\r\n};\r\n\r\nconst SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\r\nconst SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * @private\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nexport default class SingleTouchInput extends Input {\r\n  constructor() {\r\n    var proto = SingleTouchInput.prototype;\r\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\r\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\r\n\r\n    super(...arguments);\r\n    this.started = false;\r\n  }\r\n\r\n  handler(ev) {\r\n    let type = SINGLE_TOUCH_INPUT_MAP[ev.type];\r\n\r\n    // should we handle the touch events?\r\n    if (type === INPUT_START) {\r\n      this.started = true;\r\n    }\r\n\r\n    if (!this.started) {\r\n      return;\r\n    }\r\n\r\n    let touches = normalizeSingleTouches.call(this, ev, type);\r\n\r\n    // when done, reset the started state\r\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\r\n      this.started = false;\r\n    }\r\n\r\n    this.callback(this.manager, type, {\r\n      pointers: touches[0],\r\n      changedPointers: touches[1],\r\n      pointerType: INPUT_TYPE_TOUCH,\r\n      srcEvent: ev\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction normalizeSingleTouches(ev, type) {\r\n  let all = toArray(ev.touches);\r\n  let changed = toArray(ev.changedTouches);\r\n\r\n  if (type & (INPUT_END | INPUT_CANCEL)) {\r\n    all = uniqueArray(all.concat(changed), 'identifier', true);\r\n  }\r\n\r\n  return [all, changed];\r\n}\r\n","/**\r\n * @private\r\n * wrap a method with a deprecation warning and stack trace\r\n * @param {Function} method\r\n * @param {String} name\r\n * @param {String} message\r\n * @returns {Function} A new function wrapping the supplied method.\r\n */\r\nexport default function deprecate(method, name, message) {\r\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\r\n  return function() {\r\n    let e = new Error('get-stack-trace');\r\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\r\n        .replace(/^\\s+at\\s+/gm, '')\r\n        .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\r\n\r\n    let log = window.console && (window.console.warn || window.console.log);\r\n    if (log) {\r\n      log.call(window.console, deprecationMessage, stack);\r\n    }\r\n    return method.apply(this, arguments);\r\n  };\r\n}\r\n","import deprecate from './deprecate';\r\n/**\r\n * @private\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge=false]\r\n * @returns {Object} dest\r\n */\r\nconst extend = deprecate((dest, src, merge) => {\r\n  let keys = Object.keys(src);\r\n  let i = 0;\r\n  while (i < keys.length) {\r\n    if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n      dest[keys[i]] = src[keys[i]];\r\n    }\r\n    i++;\r\n  }\r\n  return dest;\r\n}, 'extend', 'Use `assign`.');\r\n\r\nexport default extend;\r\n","import deprecate from './deprecate';\r\nimport extend from './extend';\r\n/**\r\n * @private\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nconst merge = deprecate((dest, src) => {\r\n  return extend(dest, src, true);\r\n}, 'merge', 'Use `assign`.');\r\n\r\nexport default merge;\r\n","import assign from './assign';\r\n/**\r\n * @private\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nexport default function inherit(child, base, properties) {\r\n  let baseP = base.prototype;\r\n  let childP;\r\n\r\n  childP = child.prototype = Object.create(baseP);\r\n  childP.constructor = child;\r\n  childP._super = baseP;\r\n\r\n  if (properties) {\r\n    assign(childP, properties);\r\n  }\r\n}\r\n","/**\r\n * @private\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nexport default function bindFn(fn, context) {\r\n  return function boundFn() {\r\n    return fn.apply(context, arguments);\r\n  };\r\n}\r\n","import Manager from \"./manager\";\r\nimport defaults, { preset } from \"./defaults\";\r\nimport assign from './utils/assign';\r\nimport {\r\n  INPUT_START,\r\n  INPUT_MOVE,\r\n  INPUT_END,\r\n  INPUT_CANCEL,\r\n  DIRECTION_NONE,\r\n  DIRECTION_LEFT,\r\n  DIRECTION_RIGHT,\r\n  DIRECTION_UP,\r\n  DIRECTION_DOWN,\r\n  DIRECTION_HORIZONTAL,\r\n  DIRECTION_VERTICAL,\r\n  DIRECTION_ALL,\r\n} from \"./inputjs/input-consts\";\r\nimport {\r\n  STATE_POSSIBLE,\r\n  STATE_BEGAN,\r\n  STATE_CHANGED,\r\n  STATE_ENDED,\r\n  STATE_RECOGNIZED,\r\n  STATE_CANCELLED,\r\n  STATE_FAILED,\r\n} from \"./recognizerjs/recognizer-consts\";\r\n\r\nimport Input from \"./inputjs/input-constructor\";\r\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\r\nimport TouchInput from \"./input/touch\";\r\nimport MouseInput from \"./input/mouse\";\r\nimport PointerEventInput from \"./input/pointerevent\";\r\nimport SingleTouchInput from \"./input/singletouch\";\r\nimport TouchMouseInput from \"./input/touchmouse\";\r\n\r\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\r\nimport AttrRecognizer from \"./recognizers/attribute\";\r\nimport TapRecognizer from \"./recognizers/tap\";\r\nimport PanRecognizer from \"./recognizers/pan\";\r\nimport SwipeRecognizer from \"./recognizers/swipe\";\r\nimport PinchRecognizer from \"./recognizers/pinch\";\r\nimport RotateRecognizer from \"./recognizers/rotate\";\r\nimport PressRecognizer from \"./recognizers/press\";\r\n\r\nimport addEventListeners from \"./utils/add-event-listeners\";\r\nimport removeEventListeners from \"./utils/remove-event-listeners\";\r\nimport each from \"./utils/each\";\r\nimport merge from \"./utils/merge\";\r\nimport extend from \"./utils/extend\";\r\nimport inherit from \"./utils/inherit\";\r\nimport bindFn from \"./utils/bind-fn\";\r\nimport prefixed from \"./utils/prefixed\";\r\nimport toArray from \"./utils/to-array\";\r\nimport uniqueArray from \"./utils/unique-array\";\r\nimport splitStr from \"./utils/split-str\";\r\nimport inArray from \"./utils/in-array\";\r\nimport boolOrFn from \"./utils/bool-or-fn\";\r\nimport hasParent from \"./utils/has-parent\";\r\n/**\r\n * @private\r\n * Simple way to create a manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nexport default class Hammer {\r\n\t/**\r\n   * @private\r\n   * @const {string}\r\n   */\r\n\tstatic VERSION = \"#__VERSION__#\";\r\n\tstatic DIRECTION_ALL = DIRECTION_ALL;\r\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\r\n\tstatic DIRECTION_LEFT = DIRECTION_LEFT;\r\n\tstatic DIRECTION_RIGHT = DIRECTION_RIGHT;\r\n\tstatic DIRECTION_UP = DIRECTION_UP;\r\n\tstatic DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\r\n\tstatic DIRECTION_VERTICAL = DIRECTION_VERTICAL;\r\n\tstatic DIRECTION_NONE = DIRECTION_NONE;\r\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\r\n\tstatic INPUT_START = INPUT_START;\r\n\tstatic INPUT_MOVE = INPUT_MOVE;\r\n  static INPUT_END = INPUT_END;\r\n\tstatic INPUT_CANCEL = INPUT_CANCEL;\r\n\tstatic STATE_POSSIBLE = STATE_POSSIBLE;\r\n\tstatic STATE_BEGAN = STATE_BEGAN;\r\n\tstatic STATE_CHANGED = STATE_CHANGED;\r\n\tstatic STATE_ENDED = STATE_ENDED;\r\n\tstatic STATE_RECOGNIZED = STATE_RECOGNIZED;\r\n\tstatic STATE_CANCELLED = STATE_CANCELLED;\r\n\tstatic STATE_FAILED = STATE_FAILED;\r\n\tstatic Manager = Manager;\r\n\tstatic Input = Input;\r\n\tstatic TouchAction = TouchAction;\r\n\tstatic TouchInput = TouchInput;\r\n\tstatic MouseInput = MouseInput;\r\n\tstatic PointerEventInput = PointerEventInput;\r\n\tstatic TouchMouseInput = TouchMouseInput;\r\n\tstatic SingleTouchInput = SingleTouchInput;\r\n\tstatic Recognizer = Recognizer;\r\n\tstatic AttrRecognizer = AttrRecognizer;\r\n\tstatic Tap = TapRecognizer;\r\n\tstatic Pan = PanRecognizer;\r\n\tstatic Swipe = SwipeRecognizer;\r\n\tstatic Pinch = PinchRecognizer;\r\n\tstatic Rotate = RotateRecognizer;\r\n\tstatic Press = PressRecognizer;\r\n\tstatic on = addEventListeners;\r\n\tstatic off = removeEventListeners;\r\n\tstatic each = each;\r\n\tstatic merge = merge;\r\n\tstatic extend = extend;\r\n\tstatic bindFn = bindFn;\r\n\tstatic assign = assign;\r\n\tstatic inherit = inherit;\r\n\tstatic bindFn = bindFn;\r\n\tstatic prefixed = prefixed;\r\n\tstatic toArray = toArray;\r\n\tstatic inArray = inArray;\r\n\tstatic uniqueArray = uniqueArray;\r\n\tstatic splitStr = splitStr;\r\n\tstatic boolOrFn = boolOrFn;\r\n\tstatic hasParent = hasParent;\r\n\tstatic addEventListeners = addEventListeners;\r\n\tstatic removeEventListeners = removeEventListeners;\r\n\tstatic defaults = assign({}, defaults, { preset });\r\n\tconstructor(element, options = {}) {\r\n\t\treturn new Manager(element, {\r\n\t\t\trecognizers: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        ...preset\r\n\t\t\t],\r\n\t\t\t...options,\r\n\t\t});\r\n\t}\r\n}\r\n"],"names":["win","Object","assign","target","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","VENDOR_PREFIXES","TEST_ELEMENT","document","style","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","prefixed","obj","property","prefix","prop","camelProp","toUpperCase","slice","i","window","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","undefined","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","forEach","val","getTouchActionProps","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_MOUSE","COMPUTE_INTERVAL","INPUT_START","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","each","iterator","context","call","boolOrFn","args","apply","inStr","str","find","indexOf","TouchAction","manager","value","set","this","compute","element","actions","toLowerCase","trim","update","options","touchAction","recognizers","recognizer","enable","concat","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","input","srcEvent","direction","offsetDirection","session","prevented","preventDefault","hasNone","isTapPointer","pointers","isTapMovement","distance","isTapTouchTime","deltaTime","preventSrc","hasParent","node","parent","parentNode","getCenter","pointersLength","x","clientX","y","clientY","simpleCloneInputData","timeStamp","center","deltaX","deltaY","getDistance","p1","p2","props","sqrt","getAngle","atan2","PI","getDirection","getVelocity","computeInputData","firstInput","firstMultiple","offset","prevDelta","prevInput","offsetCenter","angle","offsetDelta","eventType","start","end","startSorted","start0","start1","endSorted","overallVelocity","overallVelocityX","overallVelocityY","scale","rotation","identifier","maxPointers","velocity","velocityX","velocityY","last","lastInterval","v","computeIntervalInputData","srcEventTarget","composedPath","path","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","emit","recognize","splitStr","split","addEventListeners","types","handler","type","addEventListener","removeEventListeners","removeEventListener","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","callback","self","inputTarget","domHandler","ev","init","evEl","evTarget","evWin","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","proto","prototype","store","_this","pointerEvents","removePointer","eventTypeNormalized","replace","pointerType","isTouch","storeIndex","pointerId","button","push","splice","toArray","Array","uniqueArray","key","sort","results","values","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TouchInput","targetIds","touches","targetTouches","allTouches","changedTouches","changedTargetTouches","filter","touch","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MouseInput","pressed","which","DEDUP_TIMEOUT","DEDUP_DISTANCE","setLastTouch","eventData","primaryTouch","lastTouch","lts","lastTouches","setTimeout","TouchMouseInput","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","t","dx","dy","mouse","invokeArrayArg","arg","fn","isArray","_uniqueId","getRecognizerByNameIfManager","otherRecognizer","get","stateStr","state","Recognizer","id","simultaneous","requireFail","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","TapRecognizer","taps","interval","time","threshold","posThreshold","pTime","pCenter","_timer","_input","count","validPointers","validMovement","validTouchTime","failTimeout","validInterval","validMultiTap","_this2","_this3","clearTimeout","tapCount","AttrRecognizer","_Recognizer","attrTest","optionPointers","isRecognized","isValid","directionStr","PanRecognizer","pX","pY","directionTest","hasMoved","SwipeRecognizer","_AttrRecognizer","PinchRecognizer","inOut","RotateRecognizer","PressRecognizer","validTime","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","preset","toggleCssProps","add","name","oldCssProps","Manager","defaults","handlers","item","stop","force","stopped","curRecognizer","existing","remove","targetRecognizer","on","events","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","SINGLE_TOUCH_INPUT_MAP","SingleTouchInput","started","all","changed","deprecate","method","message","deprecationMessage","e","Error","stack","log","console","warn","extend","dest","merge","keys","inherit","child","base","properties","childP","baseP","create","constructor","_super","bindFn","Hammer","VERSION","INPUT_MOVE","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press"],"mappings":"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"}